# Spectra - Cursor AI Rules

## Before Completing Any Task

**Always run these commands to ensure code quality:**

```bash
ruff format src tests && ruff check src tests --fix && mypy src/spectra && pytest
```

Or individually:
- Format: `ruff format src tests`
- Lint: `ruff check src tests --fix`
- Types: `mypy src/spectra`
- Tests: `pytest`

---

## Project Overview

Spectra is a CLI tool that syncs markdown/YAML user stories to issue trackers (Jira, GitHub Issues, Linear, Azure DevOps). It uses Clean Architecture with Hexagonal/Ports-and-Adapters pattern.

## Architecture

```
src/spectra/
â”œâ”€â”€ core/           # Domain layer - entities, enums, ports (interfaces)
â”œâ”€â”€ adapters/       # Infrastructure - parsers, API clients
â”œâ”€â”€ application/    # Use cases, orchestration
â””â”€â”€ cli/            # Commands, output formatting
```

### Key Principles
- **Dependency Inversion**: Core depends on abstractions, adapters implement them
- **Ports & Adapters**: External systems accessed only through port interfaces
- **Domain-Driven**: Rich domain entities with behavior, not anemic models

## Code Conventions

### Python
- Python 3.11+ with full type hints
- Use `dataclass` for domain entities
- Use `Enum` for constrained values (Status, Priority)
- Use `Protocol` for interfaces (structural subtyping)
- Google-style docstrings

### Imports
```python
# Standard library
from pathlib import Path
from dataclasses import dataclass

# Third-party
import click

# Local - always absolute imports
from spectra.core.domain.entities import UserStory
from spectra.core.domain.enums import Status, Priority
```

### Testing
- pytest with fixtures
- Tests mirror src structure: `tests/adapters/`, `tests/core/`, etc.
- Use `tmp_path` for file operations
- Use `textwrap.dedent()` for multiline test content

## Key Files to Know

| File | Purpose |
|------|---------|
| `core/domain/entities.py` | Epic, UserStory, Subtask, Comment dataclasses |
| `core/domain/enums.py` | Status, Priority with `from_string()` parsing |
| `core/ports/document_parser.py` | Parser interface |
| `adapters/parsers/markdown.py` | Main markdown parser |
| `cli/app.py` | CLI entry point, Click commands |
| `cli/ai_fix.py` | AI-assisted fixing features |

## Markdown Format

Spectra parses specific markdown patterns. When working with the parser:

### Story Header
```markdown
### ğŸ”§ US-001: Story Title
### PROJ-123: Another Title
```
Regex: `r"### [^\n]* (US-\d+|[A-Z]+-\d+): ([^\n]+)"`

### Metadata
```markdown
| **Story Points** | 5 |
| **Priority** | ğŸ”´ Critical |
| **Status** | ğŸ”„ In Progress |
```

### User Story
```markdown
**As a** developer
**I want** feature X
**So that** benefit Y
```

### Status Values
- Done: `done`, `complete`, `closed`, `resolved`, `âœ…`
- In Progress: `in progress`, `in_progress`, `ğŸ”„`
- Planned: `planned`, `to do`, `backlog`, `ğŸ“‹`
- Blocked: `blocked`, `on hold`, `â¸ï¸`

### Priority Values
- Critical: `critical`, `p0`, `blocker`, `ğŸ”´`
- High: `high`, `p1`, `ğŸŸ¡`
- Medium: `medium`, `p2`, `ğŸŸ¢`
- Low: `low`, `p3`, `minor`, `ğŸ”µ`

## Common Patterns

### Adding a Parser
```python
# In src/spectra/adapters/parsers/myformat.py
from spectra.core.ports.document_parser import DocumentParser

class MyFormatParser(DocumentParser):
    @property
    def name(self) -> str:
        return "MyFormat"
    
    @property
    def supported_extensions(self) -> list[str]:
        return [".myf"]
    
    def parse_stories(self, content: str | Path) -> list[UserStory]:
        ...
```

### Factory Pattern
```python
# Services use factory functions
def create_parser_factory(parser_type: str) -> Callable[[], DocumentParser]:
    def factory() -> DocumentParser:
        if parser_type == "markdown":
            return MarkdownParser()
        ...
    return factory
```

## Do's and Don'ts

### Do
- âœ… Add type hints to all functions
- âœ… Write tests for new features
- âœ… Use existing abstractions (ports/adapters)
- âœ… Update docs for user-facing changes
- âœ… Follow existing patterns in similar files

### Don't
- âŒ Bypass the ports layer for external systems
- âŒ Add dependencies without justification
- âŒ Break existing tests
- âŒ Change public API without updating docs
- âŒ Use relative imports across packages

## Development Commands

```bash
# Install dev dependencies
pip install -e ".[dev]"

# Run tests
pytest

# Type checking
mypy src/spectra

# Linting
ruff check src tests
ruff format src tests

# Run CLI
spectra --validate --markdown EPIC.md
spectra --list-ai-tools
```

## Test Patterns

```python
class TestMyFeature:
    @pytest.fixture
    def setup(self):
        return MyClass()
    
    def test_basic_case(self, setup):
        result = setup.do_thing("input")
        assert result.success
    
    def test_edge_case(self, setup):
        result = setup.do_thing("")
        assert not result.success
```

## When Making Changes

1. **Understand context**: Read surrounding code, check tests
2. **Match style**: Follow patterns in the file you're editing
3. **Test first**: Check existing tests, add new ones for changes
4. **Update docs**: If user-facing, update `docs/guide/`
5. **Validate**: Run `pytest` and `mypy` before committing

